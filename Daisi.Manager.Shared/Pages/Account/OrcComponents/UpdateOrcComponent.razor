@using Daisi.Razor.Components.Dialogs
<div class= "px-4 pb-4" >
    <Daisi.Razor.Components.Validation.ValidationAlert Messages=messages></Daisi.Razor.Components.Validation.ValidationAlert>

    <div class="">
        <label class="fw-bold">Name *</label>
        <p>This is the unique name for this Orc. Must be unique throughout the entire DAISI system.</p>
        <input class="form-control" @bind="Orc.Name" />
    </div>
    <div class="mt-3">
        <label class="fw-bold">Domain *</label>
        <p>This is the domain used to connect to this Orc. ex: orc1.daisinet.com</p>
        <input class="form-control" @bind="Orc.Domain" />
    </div>
    <div class="mt-3">
        <label class="fw-bold">Port *</label>
        <p>This is the port used to connect to this Orc. ex: 443</p>
        <input class="form-control" @bind="Orc.Port" type="number" />
    </div>
    <div class="mt-3">
        <label class="fw-bold">Require SSL</label>
        <p>Irrespective of the port number above, you can require SSL for this connection. This is HIGHLY recommended.</p>
        <MudSwitch Color="Color.Success" UncheckedColor="Color.Error" @bind-Value="Orc.RequiresSSL" Label=@(Orc.RequiresSSL ? "SSL is required" : "SSL is NOT Required!!") ></MudSwitch>
    </div>
    <div class="mt-3">
        <label class="fw-bold">Networks</label>
        <p>Networks are systems of Hosts, Orcs, and Consumers that work together. An Orc can orchestrate for multiple networks at the same time.
            Select the networks that this orc should be a part of.
        </p>
        <Daisi.SDK.Razor.Components.Selects.NetworksSelect @bind-SelectedNetworks=networks></Daisi.SDK.Razor.Components.Selects.NetworksSelect>
    </div>
    <div class="mt-3">
        <button class="btn btn-success" @onclick="OnSave">Save</button>
        @if (!IsNew)
        {
            <button class="btn btn-danger float-end" @onclick="OnArchive">Archive</button>
        }
    </div>
</div>

@code {
    [Inject] public OrcClientFactory OrcClientFactory { get; set; }
    [Inject] IDialogService DialogService { get; set; }

    [Parameter] public Orchestrator Orc { get; set; }
    [Parameter] public EventCallback Archived { get; set; }
    [CascadingParameter] public IMudDialogInstance MudDialog { get; set; }

    private IEnumerable<Network> networks;

    bool IsNew => string.IsNullOrWhiteSpace(Orc?.Id);
    bool processing = false;
    List<string> messages = new();

    protected async override Task OnParametersSetAsync()
    {
        networks = new HashSet<Network>(Orc.Networks.AsEnumerable().Select(n => new Network(){ Id = n.Id, Name = n.Name, IsPublic = n.IsPublic }));
    }

    async Task OnSave()
    {
        messages = new();

        if (string.IsNullOrWhiteSpace(Orc.Name))
        {
            messages.Add("Name is required.");
        }
        if (string.IsNullOrWhiteSpace(Orc.Domain))
        {
            messages.Add("Domain is required.");
        }
        if (Orc.Port == 0)
        {
            messages.Add("Port is required and must be greater than zero.");
        }
        if(!networks.Any())
        {
            messages.Add("At least one network must be selected.");
        }

        if (messages.Any())
            return;

        processing = true;
        var client = OrcClientFactory.Create();

        if (IsNew)
        {
            try
            {
                var clone = Orc.Clone();

                clone.Networks.Clear();
                clone.Networks.AddRange(networks.Select(n => new OrcNetwork() { Id = n.Id, IsPublic = n.IsPublic, Name = n.Name }));

                var result = await client.CreateAsync(new() { Orc = clone });
                if (result.Orc is null)
                {
                    messages.Add("An error occurred while creating the orc");
                    processing = false;
                    return;
                }

                Orc.MergeFrom(clone);
            }
            catch (Exception exc)
            {
                messages.Add($"An error occurred: {exc.Message}");
                processing = false;
                return;

            }
        }
        else
        {
            try
            {
                var clone = Orc.Clone();

                clone.Networks.Clear();
                clone.Networks.AddRange(networks.Select(n => new OrcNetwork() { Id = n.Id, IsPublic = n.IsPublic, Name = n.Name }));

                var result = await client.UpdateAsync(new() { Orc = clone });
                if (result.Success)
                {
                    Orc.MergeFrom(clone);
                }
                else
                {
                    messages.Add($"A server error occurred while updating the orc: {result.Message}");
                    processing = false;
                    return;
                }
            }
            catch (Exception exc)
            {
                messages.Add($"An error occurred: {exc.Message}");
                processing = false;
                return;
            }
        }

        if (MudDialog is not null)
            MudDialog.Close<Orchestrator>(Orc);

        processing = false;
    }

    async Task OnArchive()
    {
        messages = new();

        if (await DialogService.ConfirmAsync("Archive Orc?", "Are you certain that you want to archive this orc? This will disconnect all Hosts and Consumers. This is very permanent.", Color.Warning))
        {
            var client = OrcClientFactory.Create();
            var result = await client.ArchiveAsync(new() { OrcId = Orc.Id });
            if (result.Success)
            {
                await Archived.InvokeAsync();

                if (MudDialog is not null)
                    MudDialog.Close<Orchestrator>(Orc);
            }
            else
                messages.Add(result.Message);

        }
    
    }


}
